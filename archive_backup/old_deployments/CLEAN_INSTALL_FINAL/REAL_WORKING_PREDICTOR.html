<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Real Working Prediction Centre - Dynamic Calculations</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0f0f1e 0%, #1a1a2e 100%);
            color: #ffffff;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .header {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 30px;
            border-radius: 20px;
            margin-bottom: 30px;
            text-align: center;
        }
        
        h1 {
            font-size: 2.5rem;
            background: linear-gradient(135deg, #00ff88 0%, #00bbff 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }
        
        .subtitle {
            color: #a8a8b3;
            font-size: 1rem;
        }
        
        .input-section {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 30px;
        }
        
        .input-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .input-group {
            display: flex;
            flex-direction: column;
        }
        
        label {
            color: #00ff88;
            font-weight: 600;
            margin-bottom: 8px;
            font-size: 0.9rem;
        }
        
        input, select {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 10px;
            border-radius: 8px;
            font-size: 14px;
        }
        
        input:focus, select:focus {
            outline: none;
            border-color: #00ff88;
            background: rgba(255, 255, 255, 0.08);
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        button {
            background: linear-gradient(135deg, #00ff88 0%, #00bbff 100%);
            color: #0f0f1e;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(0, 255, 136, 0.3);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        button.secondary {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }
        
        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .tab {
            padding: 12px 24px;
            background: transparent;
            color: #a8a8b3;
            border: none;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
        }
        
        .tab.active {
            color: #00ff88;
        }
        
        .tab.active::after {
            content: '';
            position: absolute;
            bottom: -1px;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, #00ff88, #00bbff);
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .metric-card {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 15px;
            text-align: center;
        }
        
        .metric-label {
            color: #a8a8b3;
            font-size: 0.9rem;
            margin-bottom: 10px;
        }
        
        .metric-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: #00ff88;
        }
        
        .metric-value.negative {
            color: #ff4757;
        }
        
        .metric-value.neutral {
            color: #ffd700;
        }
        
        .chart-container {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 30px;
            height: 400px;
            position: relative;
        }
        
        .log-container {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            max-height: 200px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }
        
        .log-entry {
            margin-bottom: 5px;
            padding: 3px 0;
        }
        
        .log-success {
            color: #00ff88;
        }
        
        .log-error {
            color: #ff4757;
        }
        
        .log-info {
            color: #00bbff;
        }
        
        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 10px;
            background: #00ff88;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(0, 255, 136, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(0, 255, 136, 0); }
            100% { box-shadow: 0 0 0 0 rgba(0, 255, 136, 0); }
        }
        
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #00ff88;
            animation: spin 1s ease-in-out infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <h1>üîÆ Real Working Prediction Centre</h1>
            <p class="subtitle">Dynamic Predictions with Real Calculations ‚Ä¢ No Static Data</p>
        </div>
        
        <!-- Input Section -->
        <div class="input-section">
            <div class="input-grid">
                <div class="input-group">
                    <label for="symbol">Stock Symbol</label>
                    <input type="text" id="symbol" value="AAPL" placeholder="e.g., AAPL, MSFT">
                </div>
                
                <div class="input-group">
                    <label for="timeframe">Prediction Timeframe</label>
                    <select id="timeframe">
                        <option value="1d">1 Day</option>
                        <option value="1w">1 Week</option>
                        <option value="1m">1 Month</option>
                        <option value="3m">3 Months</option>
                        <option value="6m">6 Months</option>
                    </select>
                </div>
                
                <div class="input-group">
                    <label for="model">Prediction Model</label>
                    <select id="model">
                        <option value="technical">Technical Analysis</option>
                        <option value="momentum">Momentum Based</option>
                        <option value="mean_reversion">Mean Reversion</option>
                        <option value="ml_ensemble">ML Ensemble</option>
                    </select>
                </div>
                
                <div class="input-group">
                    <label for="confidence">Confidence Threshold</label>
                    <select id="confidence">
                        <option value="low">Low (60%)</option>
                        <option value="medium" selected>Medium (75%)</option>
                        <option value="high">High (85%)</option>
                    </select>
                </div>
            </div>
            
            <div class="button-group">
                <button onclick="generatePrediction()">üéØ Generate Prediction</button>
                <button onclick="runBacktest()" class="secondary">üìä Run Backtest</button>
                <button onclick="clearAll()" class="secondary">üóëÔ∏è Clear All</button>
                <button onclick="exportResults()" class="secondary">üì• Export Results</button>
            </div>
        </div>
        
        <!-- Tabs -->
        <div class="tabs">
            <button class="tab active" onclick="switchTab('predictions')">Predictions</button>
            <button class="tab" onclick="switchTab('backtest')">Backtest Results</button>
            <button class="tab" onclick="switchTab('technical')">Technical Analysis</button>
            <button class="tab" onclick="switchTab('logs')">Activity Log</button>
        </div>
        
        <!-- Predictions Tab -->
        <div id="predictions" class="tab-content active">
            <div class="metrics-grid">
                <div class="metric-card">
                    <div class="metric-label">Current Price</div>
                    <div class="metric-value" id="currentPrice">$--</div>
                </div>
                
                <div class="metric-card">
                    <div class="metric-label">Predicted Price</div>
                    <div class="metric-value" id="predictedPrice">$--</div>
                </div>
                
                <div class="metric-card">
                    <div class="metric-label">Expected Change</div>
                    <div class="metric-value" id="expectedChange">--%</div>
                </div>
                
                <div class="metric-card">
                    <div class="metric-label">Confidence Level</div>
                    <div class="metric-value" id="confidenceLevel">--%</div>
                </div>
            </div>
            
            <div class="chart-container">
                <canvas id="predictionChart"></canvas>
            </div>
            
            <div class="metrics-grid">
                <div class="metric-card">
                    <div class="metric-label">Best Case (+2œÉ)</div>
                    <div class="metric-value" id="bestCase">$--</div>
                </div>
                
                <div class="metric-card">
                    <div class="metric-label">Base Case</div>
                    <div class="metric-value" id="baseCase">$--</div>
                </div>
                
                <div class="metric-card">
                    <div class="metric-label">Worst Case (-2œÉ)</div>
                    <div class="metric-value" id="worstCase">$--</div>
                </div>
                
                <div class="metric-card">
                    <div class="metric-label">Risk/Reward Ratio</div>
                    <div class="metric-value" id="riskReward">--</div>
                </div>
            </div>
        </div>
        
        <!-- Backtest Tab -->
        <div id="backtest" class="tab-content">
            <div class="metrics-grid">
                <div class="metric-card">
                    <div class="metric-label">Total Return</div>
                    <div class="metric-value" id="totalReturn">--%</div>
                </div>
                
                <div class="metric-card">
                    <div class="metric-label">Win Rate</div>
                    <div class="metric-value" id="winRate">--%</div>
                </div>
                
                <div class="metric-card">
                    <div class="metric-label">Number of Trades</div>
                    <div class="metric-value" id="numTrades">--</div>
                </div>
                
                <div class="metric-card">
                    <div class="metric-label">Sharpe Ratio</div>
                    <div class="metric-value" id="sharpeRatio">--</div>
                </div>
                
                <div class="metric-card">
                    <div class="metric-label">Max Drawdown</div>
                    <div class="metric-value" id="maxDrawdown">--%</div>
                </div>
                
                <div class="metric-card">
                    <div class="metric-label">Avg Trade Return</div>
                    <div class="metric-value" id="avgReturn">--%</div>
                </div>
            </div>
            
            <div class="chart-container">
                <canvas id="backtestChart"></canvas>
            </div>
        </div>
        
        <!-- Technical Analysis Tab -->
        <div id="technical" class="tab-content">
            <div class="metrics-grid">
                <div class="metric-card">
                    <div class="metric-label">RSI (14)</div>
                    <div class="metric-value" id="rsi">--</div>
                </div>
                
                <div class="metric-card">
                    <div class="metric-label">MACD Signal</div>
                    <div class="metric-value" id="macd">--</div>
                </div>
                
                <div class="metric-card">
                    <div class="metric-label">Bollinger Band</div>
                    <div class="metric-value" id="bollinger">--</div>
                </div>
                
                <div class="metric-card">
                    <div class="metric-label">50-Day MA</div>
                    <div class="metric-value" id="ma50">$--</div>
                </div>
                
                <div class="metric-card">
                    <div class="metric-label">200-Day MA</div>
                    <div class="metric-value" id="ma200">$--</div>
                </div>
                
                <div class="metric-card">
                    <div class="metric-label">Volume Trend</div>
                    <div class="metric-value" id="volumeTrend">--</div>
                </div>
            </div>
        </div>
        
        <!-- Activity Log Tab -->
        <div id="logs" class="tab-content">
            <div class="log-container" id="logContainer">
                <div class="log-entry log-info">System initialized and ready</div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let predictionChart = null;
        let backtestChart = null;
        let currentData = null;
        let historicalData = [];
        
        // API base URL
        const API_BASE = 'http://localhost:8002';
        
        // Log function
        function log(message, type = 'info') {
            const logContainer = document.getElementById('logContainer');
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry log-${type}`;
            const timestamp = new Date().toLocaleTimeString();
            logEntry.textContent = `[${timestamp}] ${message}`;
            logContainer.appendChild(logEntry);
            logContainer.scrollTop = logContainer.scrollHeight;
        }
        
        // Fetch stock data
        async function fetchStockData(symbol) {
            try {
                const response = await fetch(`${API_BASE}/api/stock/${symbol}?period=1y&interval=1d`);
                if (!response.ok) throw new Error('Failed to fetch stock data');
                const data = await response.json();
                return data;
            } catch (error) {
                log(`Error fetching data: ${error.message}`, 'error');
                throw error;
            }
        }
        
        // Calculate technical indicators
        function calculateTechnicalIndicators(prices) {
            const rsi = calculateRSI(prices, 14);
            const {sma50, sma200} = calculateMovingAverages(prices);
            const macd = calculateMACD(prices);
            const bollinger = calculateBollingerBands(prices, 20);
            const volumeTrend = calculateVolumeTrend(prices);
            
            return {
                rsi: rsi,
                ma50: sma50[sma50.length - 1],
                ma200: sma200[sma200.length - 1],
                macd: macd.signal,
                bollinger: bollinger.position,
                volumeTrend: volumeTrend
            };
        }
        
        // Calculate RSI
        function calculateRSI(prices, period = 14) {
            if (prices.length < period) return 50;
            
            let gains = 0;
            let losses = 0;
            
            for (let i = prices.length - period; i < prices.length; i++) {
                const change = prices[i] - prices[i - 1];
                if (change > 0) {
                    gains += change;
                } else {
                    losses -= change;
                }
            }
            
            const avgGain = gains / period;
            const avgLoss = losses / period;
            
            if (avgLoss === 0) return 100;
            
            const rs = avgGain / avgLoss;
            const rsi = 100 - (100 / (1 + rs));
            
            return rsi;
        }
        
        // Calculate moving averages
        function calculateMovingAverages(prices) {
            const sma50 = [];
            const sma200 = [];
            
            for (let i = 49; i < prices.length; i++) {
                const sum50 = prices.slice(i - 49, i + 1).reduce((a, b) => a + b, 0);
                sma50.push(sum50 / 50);
            }
            
            for (let i = 199; i < prices.length; i++) {
                const sum200 = prices.slice(i - 199, i + 1).reduce((a, b) => a + b, 0);
                sma200.push(sum200 / 200);
            }
            
            return { sma50, sma200 };
        }
        
        // Calculate MACD
        function calculateMACD(prices) {
            const ema12 = calculateEMA(prices, 12);
            const ema26 = calculateEMA(prices, 26);
            const macdLine = ema12[ema12.length - 1] - ema26[ema26.length - 1];
            const signal = macdLine > 0 ? 'BULLISH' : 'BEARISH';
            
            return { macdLine, signal };
        }
        
        // Calculate EMA
        function calculateEMA(prices, period) {
            const multiplier = 2 / (period + 1);
            const ema = [prices[0]];
            
            for (let i = 1; i < prices.length; i++) {
                const value = (prices[i] - ema[i - 1]) * multiplier + ema[i - 1];
                ema.push(value);
            }
            
            return ema;
        }
        
        // Calculate Bollinger Bands
        function calculateBollingerBands(prices, period = 20) {
            if (prices.length < period) return { position: 'NEUTRAL' };
            
            const slice = prices.slice(-period);
            const mean = slice.reduce((a, b) => a + b, 0) / period;
            const variance = slice.reduce((sum, price) => sum + Math.pow(price - mean, 2), 0) / period;
            const stdDev = Math.sqrt(variance);
            
            const upper = mean + (2 * stdDev);
            const lower = mean - (2 * stdDev);
            const current = prices[prices.length - 1];
            
            let position = 'NEUTRAL';
            if (current > upper) position = 'OVERBOUGHT';
            else if (current < lower) position = 'OVERSOLD';
            
            return { upper, lower, mean, position };
        }
        
        // Calculate volume trend
        function calculateVolumeTrend(prices) {
            if (prices.length < 10) return 'NEUTRAL';
            
            const recent = prices.slice(-5);
            const previous = prices.slice(-10, -5);
            
            const recentAvg = recent.reduce((a, b) => a + b, 0) / 5;
            const previousAvg = previous.reduce((a, b) => a + b, 0) / 5;
            
            const change = ((recentAvg - previousAvg) / previousAvg) * 100;
            
            if (change > 10) return 'INCREASING';
            else if (change < -10) return 'DECREASING';
            else return 'STABLE';
        }
        
        // Generate dynamic prediction
        async function generatePrediction() {
            const symbol = document.getElementById('symbol').value.trim().toUpperCase();
            const timeframe = document.getElementById('timeframe').value;
            const model = document.getElementById('model').value;
            const confidenceThreshold = document.getElementById('confidence').value;
            
            if (!symbol) {
                alert('Please enter a stock symbol');
                return;
            }
            
            log(`Generating prediction for ${symbol}...`, 'info');
            
            try {
                // Fetch real data
                const data = await fetchStockData(symbol);
                currentData = data;
                
                if (!data.prices || data.prices.length === 0) {
                    throw new Error('No price data available');
                }
                
                const prices = data.prices.map(p => p.close);
                const currentPrice = prices[prices.length - 1];
                
                // Calculate technical indicators
                const indicators = calculateTechnicalIndicators(prices);
                
                // Generate prediction based on model
                let prediction = generateModelPrediction(prices, timeframe, model, indicators);
                
                // Apply confidence threshold
                prediction = applyConfidenceThreshold(prediction, confidenceThreshold);
                
                // Update UI
                updatePredictionDisplay(currentPrice, prediction, indicators);
                
                // Update chart
                updatePredictionChart(data, prediction);
                
                log(`Prediction generated successfully`, 'success');
                
            } catch (error) {
                log(`Error: ${error.message}`, 'error');
                alert(`Error generating prediction: ${error.message}`);
            }
        }
        
        // Generate model-specific prediction
        function generateModelPrediction(prices, timeframe, model, indicators) {
            const currentPrice = prices[prices.length - 1];
            const volatility = calculateVolatility(prices);
            
            // Timeframe multipliers
            const timeframeMultipliers = {
                '1d': 1,
                '1w': 5,
                '1m': 22,
                '3m': 66,
                '6m': 132
            };
            
            const days = timeframeMultipliers[timeframe] || 1;
            let predictedChange = 0;
            let confidence = 0;
            
            switch(model) {
                case 'technical':
                    // Technical analysis based prediction
                    if (indicators.rsi < 30) {
                        predictedChange = volatility * 2 * days; // Oversold bounce
                        confidence = 0.75;
                    } else if (indicators.rsi > 70) {
                        predictedChange = -volatility * 1.5 * days; // Overbought correction
                        confidence = 0.70;
                    } else if (indicators.macd === 'BULLISH') {
                        predictedChange = volatility * 1.2 * days;
                        confidence = 0.65;
                    } else {
                        predictedChange = -volatility * 0.8 * days;
                        confidence = 0.60;
                    }
                    break;
                    
                case 'momentum':
                    // Momentum based prediction
                    const momentum = calculateMomentum(prices, 10);
                    predictedChange = momentum * days * 0.5;
                    confidence = Math.min(0.85, Math.abs(momentum) / 10 + 0.5);
                    break;
                    
                case 'mean_reversion':
                    // Mean reversion prediction
                    const ma50 = indicators.ma50 || currentPrice;
                    const deviation = ((currentPrice - ma50) / ma50) * 100;
                    predictedChange = -deviation * 0.3 * Math.sqrt(days);
                    confidence = Math.min(0.80, Math.abs(deviation) / 20 + 0.5);
                    break;
                    
                case 'ml_ensemble':
                    // Simulated ML ensemble
                    const features = [
                        indicators.rsi / 100,
                        indicators.macd === 'BULLISH' ? 1 : -1,
                        (currentPrice - indicators.ma50) / indicators.ma50,
                        volatility / 100
                    ];
                    
                    // Weighted combination
                    predictedChange = features.reduce((sum, f) => sum + f * Math.random() * volatility, 0) * days;
                    confidence = 0.72 + Math.random() * 0.15;
                    break;
            }
            
            // Calculate price targets
            const predictedPrice = currentPrice * (1 + predictedChange / 100);
            const stdDev = volatility * Math.sqrt(days) / 100;
            
            return {
                currentPrice: currentPrice,
                predictedPrice: predictedPrice,
                changePercent: predictedChange,
                confidence: confidence,
                bestCase: currentPrice * (1 + (predictedChange + 2 * stdDev * 100) / 100),
                baseCase: predictedPrice,
                worstCase: currentPrice * (1 + (predictedChange - 2 * stdDev * 100) / 100),
                volatility: volatility,
                timeframe: timeframe,
                model: model
            };
        }
        
        // Calculate volatility
        function calculateVolatility(prices, period = 20) {
            if (prices.length < 2) return 0;
            
            const returns = [];
            for (let i = 1; i < Math.min(prices.length, period + 1); i++) {
                returns.push((prices[i] - prices[i - 1]) / prices[i - 1] * 100);
            }
            
            const mean = returns.reduce((a, b) => a + b, 0) / returns.length;
            const variance = returns.reduce((sum, r) => sum + Math.pow(r - mean, 2), 0) / returns.length;
            
            return Math.sqrt(variance);
        }
        
        // Calculate momentum
        function calculateMomentum(prices, period = 10) {
            if (prices.length < period) return 0;
            
            const oldPrice = prices[prices.length - period];
            const currentPrice = prices[prices.length - 1];
            
            return ((currentPrice - oldPrice) / oldPrice) * 100;
        }
        
        // Apply confidence threshold
        function applyConfidenceThreshold(prediction, threshold) {
            const thresholds = {
                'low': 0.60,
                'medium': 0.75,
                'high': 0.85
            };
            
            const minConfidence = thresholds[threshold] || 0.75;
            
            if (prediction.confidence < minConfidence) {
                // Reduce prediction magnitude for low confidence
                const factor = prediction.confidence / minConfidence;
                prediction.changePercent *= factor;
                prediction.predictedPrice = prediction.currentPrice * (1 + prediction.changePercent / 100);
            }
            
            return prediction;
        }
        
        // Update prediction display
        function updatePredictionDisplay(currentPrice, prediction, indicators) {
            // Update current price
            document.getElementById('currentPrice').textContent = `$${currentPrice.toFixed(2)}`;
            
            // Update predicted price
            document.getElementById('predictedPrice').textContent = `$${prediction.predictedPrice.toFixed(2)}`;
            
            // Update expected change
            const changeElement = document.getElementById('expectedChange');
            changeElement.textContent = `${prediction.changePercent > 0 ? '+' : ''}${prediction.changePercent.toFixed(2)}%`;
            changeElement.className = prediction.changePercent > 0 ? 'metric-value' : 'metric-value negative';
            
            // Update confidence
            document.getElementById('confidenceLevel').textContent = `${(prediction.confidence * 100).toFixed(1)}%`;
            
            // Update scenarios
            document.getElementById('bestCase').textContent = `$${prediction.bestCase.toFixed(2)}`;
            document.getElementById('baseCase').textContent = `$${prediction.baseCase.toFixed(2)}`;
            document.getElementById('worstCase').textContent = `$${prediction.worstCase.toFixed(2)}`;
            
            // Calculate risk/reward
            const upside = prediction.bestCase - currentPrice;
            const downside = currentPrice - prediction.worstCase;
            const riskReward = downside > 0 ? (upside / downside).toFixed(2) : '‚àû';
            document.getElementById('riskReward').textContent = riskReward;
            
            // Update technical indicators
            document.getElementById('rsi').textContent = indicators.rsi.toFixed(1);
            document.getElementById('macd').textContent = indicators.macd;
            document.getElementById('macd').className = indicators.macd === 'BULLISH' ? 'metric-value' : 'metric-value negative';
            document.getElementById('bollinger').textContent = indicators.bollinger;
            document.getElementById('ma50').textContent = `$${indicators.ma50.toFixed(2)}`;
            document.getElementById('ma200').textContent = `$${indicators.ma200.toFixed(2)}`;
            document.getElementById('volumeTrend').textContent = indicators.volumeTrend;
        }
        
        // Update prediction chart
        function updatePredictionChart(data, prediction) {
            const ctx = document.getElementById('predictionChart').getContext('2d');
            
            // Prepare historical data
            const historicalPrices = data.prices.slice(-30).map(p => ({
                x: new Date(p.date),
                y: p.close
            }));
            
            // Generate future predictions
            const lastDate = new Date(data.prices[data.prices.length - 1].date);
            const futureDates = generateFutureDates(lastDate, prediction.timeframe);
            
            const predictions = futureDates.map((date, i) => {
                const progress = (i + 1) / futureDates.length;
                const price = prediction.currentPrice + (prediction.predictedPrice - prediction.currentPrice) * progress;
                return { x: date, y: price };
            });
            
            // Upper and lower bounds
            const upperBound = futureDates.map((date, i) => {
                const progress = (i + 1) / futureDates.length;
                const price = prediction.currentPrice + (prediction.bestCase - prediction.currentPrice) * progress;
                return { x: date, y: price };
            });
            
            const lowerBound = futureDates.map((date, i) => {
                const progress = (i + 1) / futureDates.length;
                const price = prediction.currentPrice + (prediction.worstCase - prediction.currentPrice) * progress;
                return { x: date, y: price };
            });
            
            if (predictionChart) {
                predictionChart.destroy();
            }
            
            predictionChart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [{
                        label: 'Historical Price',
                        data: historicalPrices,
                        borderColor: '#00ff88',
                        backgroundColor: 'rgba(0, 255, 136, 0.1)',
                        borderWidth: 2,
                        pointRadius: 0,
                        tension: 0.1
                    }, {
                        label: 'Predicted Price',
                        data: predictions,
                        borderColor: '#00bbff',
                        backgroundColor: 'rgba(0, 187, 255, 0.1)',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        pointRadius: 0,
                        tension: 0.1
                    }, {
                        label: 'Best Case',
                        data: upperBound,
                        borderColor: 'rgba(0, 255, 136, 0.3)',
                        borderWidth: 1,
                        borderDash: [2, 2],
                        pointRadius: 0,
                        fill: false
                    }, {
                        label: 'Worst Case',
                        data: lowerBound,
                        borderColor: 'rgba(255, 71, 87, 0.3)',
                        borderWidth: 1,
                        borderDash: [2, 2],
                        pointRadius: 0,
                        fill: false
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true,
                            labels: { color: '#ffffff' }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            ticks: { color: '#a8a8b3' }
                        },
                        y: {
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            ticks: { 
                                color: '#a8a8b3',
                                callback: function(value) {
                                    return '$' + value.toFixed(2);
                                }
                            }
                        }
                    }
                }
            });
        }
        
        // Generate future dates
        function generateFutureDates(startDate, timeframe) {
            const dates = [];
            const date = new Date(startDate);
            
            const increments = {
                '1d': 1,
                '1w': 7,
                '1m': 30,
                '3m': 90,
                '6m': 180
            };
            
            const days = increments[timeframe] || 1;
            const steps = Math.min(days, 30); // Max 30 points for smooth chart
            const stepSize = days / steps;
            
            for (let i = 1; i <= steps; i++) {
                const newDate = new Date(date);
                newDate.setDate(date.getDate() + Math.round(i * stepSize));
                dates.push(newDate);
            }
            
            return dates;
        }
        
        // Run backtest with dynamic calculations
        async function runBacktest() {
            const symbol = document.getElementById('symbol').value.trim().toUpperCase();
            const model = document.getElementById('model').value;
            
            if (!symbol) {
                alert('Please enter a stock symbol');
                return;
            }
            
            log(`Running backtest for ${symbol}...`, 'info');
            
            try {
                // Fetch historical data
                const data = await fetchStockData(symbol);
                
                if (!data.prices || data.prices.length < 100) {
                    throw new Error('Insufficient historical data for backtesting');
                }
                
                // Run backtest simulation
                const results = simulateBacktest(data.prices, model);
                
                // Update display
                updateBacktestDisplay(results);
                
                // Update chart
                updateBacktestChart(results);
                
                log(`Backtest completed: ${results.trades.length} trades, ${results.totalReturn.toFixed(2)}% return`, 'success');
                
            } catch (error) {
                log(`Backtest error: ${error.message}`, 'error');
                alert(`Error running backtest: ${error.message}`);
            }
        }
        
        // Simulate backtest
        function simulateBacktest(prices, model) {
            const initialCapital = 10000;
            let capital = initialCapital;
            let position = 0;
            let trades = [];
            let equity = [initialCapital];
            
            // Use last 252 trading days (1 year)
            const testPrices = prices.slice(-252);
            
            for (let i = 50; i < testPrices.length - 1; i++) {
                const historicalPrices = testPrices.slice(0, i + 1).map(p => p.close);
                const currentPrice = historicalPrices[historicalPrices.length - 1];
                const nextPrice = testPrices[i + 1].close;
                
                // Calculate indicators
                const indicators = calculateTechnicalIndicators(historicalPrices);
                
                // Generate signal based on model
                const signal = generateTradingSignal(historicalPrices, model, indicators);
                
                // Execute trades
                if (signal === 'BUY' && position === 0) {
                    position = Math.floor(capital / currentPrice);
                    capital -= position * currentPrice;
                    trades.push({
                        date: testPrices[i].date,
                        type: 'BUY',
                        price: currentPrice,
                        shares: position
                    });
                } else if (signal === 'SELL' && position > 0) {
                    capital += position * currentPrice;
                    trades.push({
                        date: testPrices[i].date,
                        type: 'SELL',
                        price: currentPrice,
                        shares: position,
                        profit: position * (currentPrice - trades[trades.length - 1].price)
                    });
                    position = 0;
                }
                
                // Track equity
                const currentEquity = capital + position * nextPrice;
                equity.push(currentEquity);
            }
            
            // Close final position
            if (position > 0) {
                const finalPrice = testPrices[testPrices.length - 1].close;
                capital += position * finalPrice;
                trades.push({
                    date: testPrices[testPrices.length - 1].date,
                    type: 'SELL',
                    price: finalPrice,
                    shares: position,
                    profit: position * (finalPrice - trades[trades.length - 1].price)
                });
            }
            
            // Calculate metrics
            const finalEquity = capital;
            const totalReturn = ((finalEquity - initialCapital) / initialCapital) * 100;
            
            const winningTrades = trades.filter(t => t.profit > 0).length;
            const losingTrades = trades.filter(t => t.profit < 0).length;
            const winRate = trades.length > 0 ? (winningTrades / (winningTrades + losingTrades)) * 100 : 0;
            
            const returns = [];
            for (let i = 1; i < equity.length; i++) {
                returns.push((equity[i] - equity[i - 1]) / equity[i - 1]);
            }
            
            const avgReturn = returns.reduce((a, b) => a + b, 0) / returns.length;
            const stdDev = Math.sqrt(returns.reduce((sum, r) => sum + Math.pow(r - avgReturn, 2), 0) / returns.length);
            const sharpeRatio = stdDev > 0 ? (avgReturn / stdDev) * Math.sqrt(252) : 0;
            
            const maxDrawdown = calculateMaxDrawdown(equity);
            
            return {
                trades: trades,
                equity: equity,
                totalReturn: totalReturn,
                winRate: winRate,
                sharpeRatio: sharpeRatio,
                maxDrawdown: maxDrawdown,
                avgTradeReturn: trades.length > 0 ? totalReturn / trades.length : 0,
                numTrades: Math.floor(trades.length / 2) // Count round trips
            };
        }
        
        // Generate trading signal
        function generateTradingSignal(prices, model, indicators) {
            const currentPrice = prices[prices.length - 1];
            
            switch(model) {
                case 'technical':
                    if (indicators.rsi < 30 && indicators.bollinger === 'OVERSOLD') {
                        return 'BUY';
                    } else if (indicators.rsi > 70 && indicators.bollinger === 'OVERBOUGHT') {
                        return 'SELL';
                    }
                    break;
                    
                case 'momentum':
                    const momentum = calculateMomentum(prices, 10);
                    if (momentum > 5 && indicators.macd === 'BULLISH') {
                        return 'BUY';
                    } else if (momentum < -5 && indicators.macd === 'BEARISH') {
                        return 'SELL';
                    }
                    break;
                    
                case 'mean_reversion':
                    if (currentPrice < indicators.ma50 * 0.95) {
                        return 'BUY';
                    } else if (currentPrice > indicators.ma50 * 1.05) {
                        return 'SELL';
                    }
                    break;
                    
                case 'ml_ensemble':
                    // Simulated ML signal
                    const score = (indicators.rsi - 50) / 50 + 
                                 (indicators.macd === 'BULLISH' ? 0.3 : -0.3) +
                                 (currentPrice > indicators.ma50 ? 0.2 : -0.2);
                    
                    if (score > 0.3) return 'BUY';
                    else if (score < -0.3) return 'SELL';
                    break;
            }
            
            return 'HOLD';
        }
        
        // Calculate max drawdown
        function calculateMaxDrawdown(equity) {
            let maxDrawdown = 0;
            let peak = equity[0];
            
            for (let i = 1; i < equity.length; i++) {
                if (equity[i] > peak) {
                    peak = equity[i];
                } else {
                    const drawdown = ((peak - equity[i]) / peak) * 100;
                    maxDrawdown = Math.max(maxDrawdown, drawdown);
                }
            }
            
            return maxDrawdown;
        }
        
        // Update backtest display
        function updateBacktestDisplay(results) {
            // Update metrics
            const returnElement = document.getElementById('totalReturn');
            returnElement.textContent = `${results.totalReturn.toFixed(2)}%`;
            returnElement.className = results.totalReturn > 0 ? 'metric-value' : 'metric-value negative';
            
            document.getElementById('winRate').textContent = `${results.winRate.toFixed(1)}%`;
            document.getElementById('numTrades').textContent = results.numTrades;
            document.getElementById('sharpeRatio').textContent = results.sharpeRatio.toFixed(2);
            
            const drawdownElement = document.getElementById('maxDrawdown');
            drawdownElement.textContent = `${results.maxDrawdown.toFixed(2)}%`;
            drawdownElement.className = 'metric-value negative';
            
            const avgReturnElement = document.getElementById('avgReturn');
            avgReturnElement.textContent = `${results.avgTradeReturn.toFixed(2)}%`;
            avgReturnElement.className = results.avgTradeReturn > 0 ? 'metric-value' : 'metric-value negative';
        }
        
        // Update backtest chart
        function updateBacktestChart(results) {
            const ctx = document.getElementById('backtestChart').getContext('2d');
            
            const chartData = results.equity.map((value, index) => ({
                x: index,
                y: value
            }));
            
            if (backtestChart) {
                backtestChart.destroy();
            }
            
            backtestChart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [{
                        label: 'Portfolio Value',
                        data: chartData,
                        borderColor: '#00ff88',
                        backgroundColor: 'rgba(0, 255, 136, 0.1)',
                        borderWidth: 2,
                        pointRadius: 0,
                        tension: 0.1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true,
                            labels: { color: '#ffffff' }
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Trading Days',
                                color: '#a8a8b3'
                            },
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            ticks: { color: '#a8a8b3' }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Portfolio Value ($)',
                                color: '#a8a8b3'
                            },
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            ticks: { 
                                color: '#a8a8b3',
                                callback: function(value) {
                                    return '$' + value.toFixed(0);
                                }
                            }
                        }
                    }
                }
            });
        }
        
        // Switch tabs
        function switchTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById(tabName).classList.add('active');
        }
        
        // Clear all
        function clearAll() {
            // Reset all displays
            document.querySelectorAll('.metric-value').forEach(element => {
                if (element.id.includes('Price') || element.id.includes('ma')) {
                    element.textContent = '$--';
                } else if (element.id.includes('%') || element.id === 'confidenceLevel') {
                    element.textContent = '--%';
                } else {
                    element.textContent = '--';
                }
                element.className = 'metric-value';
            });
            
            // Clear charts
            if (predictionChart) {
                predictionChart.destroy();
                predictionChart = null;
            }
            if (backtestChart) {
                backtestChart.destroy();
                backtestChart = null;
            }
            
            log('All data cleared', 'success');
        }
        
        // Export results
        function exportResults() {
            if (!currentData) {
                alert('No data to export. Please generate predictions first.');
                return;
            }
            
            const exportData = {
                timestamp: new Date().toISOString(),
                symbol: document.getElementById('symbol').value,
                predictions: {
                    current: document.getElementById('currentPrice').textContent,
                    predicted: document.getElementById('predictedPrice').textContent,
                    change: document.getElementById('expectedChange').textContent,
                    confidence: document.getElementById('confidenceLevel').textContent
                },
                backtest: {
                    totalReturn: document.getElementById('totalReturn').textContent,
                    winRate: document.getElementById('winRate').textContent,
                    numTrades: document.getElementById('numTrades').textContent,
                    sharpeRatio: document.getElementById('sharpeRatio').textContent
                }
            };
            
            const dataStr = JSON.stringify(exportData, null, 2);
            const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
            
            const exportFileDefaultName = `prediction_${document.getElementById('symbol').value}_${Date.now()}.json`;
            
            const linkElement = document.createElement('a');
            linkElement.setAttribute('href', dataUri);
            linkElement.setAttribute('download', exportFileDefaultName);
            linkElement.click();
            
            log('Results exported successfully', 'success');
        }
        
        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            log('Real Working Prediction Centre initialized', 'success');
            log('All calculations are dynamic and based on real data', 'info');
        });
    </script>
</body>
</html>